<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>055 예시</title>
    <style>
        .canvas {
            width: 500px;
            height: 500px;
            background-color: black;
            margin: 100px auto;
        }

        ul {
            display: flex;
            justify-content: space-around;
        }

        .canvas.red {
            background-color: red;
        }

        .canvas.yellow {
            background-color: yellow;
        }

        .canvas.green {
            background-color: green;
        }
    </style>
</head>

<body>
    <div class="canvas"></div>
    <ul>
        <li>
            <button type="button" class="btn-red">빨강</button>
        </li>
        <li>
            <button type="button" class="btn-yellow">노랑</button>
        </li>
        <li>
            <button type="button" class="btn-green">초록</button>
        </li>
    </ul>

    <script>
        // 각 요소에 접근하고, 변수에 할당.
        const canvas = document.querySelector('.canvas');
        const btnRed = document.querySelector('.btn-red');
        const btnYellow = document.querySelector('.btn-yellow');
        const btnGreen = document.querySelector('.btn-green');

	// 버튼이 할당되어 있는 변수들을 배열로 만들어 새로운 변수에 추가하자
        const btnArr = [btnRed, btnYellow, btnGreen]


    // 반복적으로 addEventListener를 붙여준다고 생각하자.
    // for문도 이용하면 좋다.
    // for(let i=0; i<btnArr.length; i++){}

        // 여기서는 forEach를 사용하겠다.
        // forEach를 사용하여 item에 btnRed, btnYellow, btnGreen이 하나씩 들어가 순환하도록 한다.
        btnArr.forEach(item => {
    
        // item.addEventListener를 한다는 것은
        // item 안에 있는 각각의 버튼에 addEventListener를 하나씩 붙여준다는 것과 같다.
        item.addEventListener('click', () => {
        
            // click 했을 때 실행되는 첫 번째 메서드 remove는 존재하는 클래스를 다 지운다.
            canvas.classList.remove('red', 'yellow', 'green');
            
            //만약 지금 순환하고 있는 item class에 btn-red가 있다면 즉, btn-red를 클릭한다면 canvas에 red라는 클래스를 추가한다.
            if(item.classList.contains("btn-red")) {
                canvas.classList.add('red')
            } else if(item.classList.contains("btn-yellow")) {
                canvas.classList.add('yellow');
            } else if(item.classList.contains("btn-green")) {
                canvas.classList.add('green');
            }
        })
    })
        //////////////////

        // remove를 하지 않으면 반복적인 이벤트가 발생하지 않는다. 즉 빨간 버튼과 노란 버튼을 누른 이후 다시 빨간 버튼을 누르면 빨간색으로 변하지 않는다.
        //왜 그럴까 class가 누적된다.
        // 개발자 도구에서 본다면 계속 add(추가)만 하고 있다. 이미 추가된 클래스이기 때문에 이미 색 변환이 종료되었구나 라고 인식하고 더 이상 색이 변하지 않는다. 내부적인 예외처리가 되어 있다.
        // 노랑을 눌렀다면 나머지 클래스를 제거해주는 것이 필요하며, 메서드 classList.remove를 사용한다.
        // 
        btnRed.addEventListener('click', () => {
            canvas.classList.remove('red', 'yellow', 'green');
            canvas.classList.add('red');
        })

        btnYellow.addEventListener('click', () => {
            canvas.classList.remove('red', 'yellow', 'green');
            canvas.classList.add('yellow');
        })

        btnGreen.addEventListener('click', () => {
            canvas.classList.remove('red', 'yellow', 'green');
            canvas.classList.add('green');
        })

        //코드가 반복되고 있다.
        // 코드를 줄이고 효율적인 코드를 작성할 필요가 있다.
    </script>
</body>

</html>